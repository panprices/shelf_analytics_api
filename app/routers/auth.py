from datetime import datetime, timedelta
from typing import Optional

import fastapi
import requests
from fastapi import Depends, Response, HTTPException
from fastapi.security import HTTPAuthorizationCredentials, HTTPBearer
from firebase_admin import auth, firestore
from jose import jwt
from starlette import status

from app.config.settings import get_settings, Settings
from app.schemas.auth import AuthenticationRequest, AuthenticationResponse, TokenData, UserMetadata
from app.security import firebase_app, JWT_ALGORITHM, JWT_SECRET_KEY

router = fastapi.APIRouter(prefix="/authenticate")
rest_api_url = "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword"


def get_user_metadata(uid: str) -> Optional[UserMetadata]:
    db = firestore.client()
    user_metadata = db.collection('shelf-analytics-user-metadata').document(uid).get()

    if not user_metadata.exists:
        return None

    return UserMetadata(**user_metadata.to_dict())


def authenticate_verified_user(uid: str) -> AuthenticationResponse:
    """
    This method should only be called once the user has verified that they are who they pretend to be either by
    providing a password or a valid firebase token.
    """

    user_metadata = get_user_metadata(uid)
    if not user_metadata:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=f"Could not properly fulfill the authentication request. User exists but no permissions assigned!",
            headers={"WWW-Authenticate": "Bearer"}
        )

    token_data = TokenData(
        uid=uid, **user_metadata.dict()
    )

    token = jwt.encode({
        "data": token_data.dict(),
        "exp": datetime.utcnow() + timedelta(hours=1)
    }, JWT_SECRET_KEY, JWT_ALGORITHM)

    return AuthenticationResponse(jwt=token, success=True)


@router.post("/withEmailAndPassword", tags=["auth"], response_model=AuthenticationResponse)
def authenticate(user: AuthenticationRequest,
                 response: Response,
                 settings: Settings = Depends(get_settings)):
    """
    This endpoint can be directly used with the credentials (email + password)

    We generate our own JWT token as opposed to simply using the one provided by firebase because we want to be able to
    include other information in the token, such as the client that the user works for, and the roles they have.
    Firebase has some documentation on creating custom tokens:
    https://firebase.google.com/docs/auth/admin/create-custom-tokens#using_a_service_account_json_file but there is no
    easy way to later check if those tokens are valid later, when we receive them in the backend. It seems like the
    purpose of these custom tokens is to allow for custom fields when writing rules for firestore (what a user can and
    can not do over there).
    """

    firebase_response = requests.post(
        rest_api_url + "?key=" + settings.firebase_api_key,
        data={
            "email": user.email,
            "password": user.password,
            "returnSecureToken": True
        })
    if firebase_response.status_code != 200:
        response.status_code = firebase_response.status_code
        return AuthenticationResponse(success=False)

    uid = auth.get_user_by_email(user.email, app=firebase_app).uid
    return authenticate_verified_user(uid)


@router.post("/withFirebaseToken", tags=["auth"], response_model=AuthenticationResponse)
def authenticate_with_firebase_token(
    credential: HTTPAuthorizationCredentials = Depends(HTTPBearer(auto_error=False))
):
    """
    This method may be used if we are already logged into firebase through the frontend, so we use firebase's token
    to generate a backend token.

    It is the only endpoint in this API where the expected authentication is different. Here we expect a Firebase Bearer
    token, for all the other authenticated endpoints we expect a token generated by this app (through this method or the
    method that takes a username and password).

    Inspired by: https://stackoverflow.com/questions/72200552/fastapi-firebase-authentication-with-jwts
    """

    if credential is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Bearer authentication is needed",
            headers={"WWW-Authenticate": 'Bearer error="invalid token"'}
        )

    try:
        token = credential.credentials
        uid = auth.verify_id_token(token)['uid']
        return authenticate_verified_user(uid)
    except Exception as err:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=f"Could not validate credentials, {err}",
            headers={"WWW-Authenticate": "Bearer"}
        )
