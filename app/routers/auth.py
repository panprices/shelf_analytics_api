import secrets
import string
from datetime import datetime, timedelta
from typing import Optional

import fastapi
import requests
import structlog
from fastapi import Depends, Response, HTTPException
from fastapi.security import HTTPAuthorizationCredentials, HTTPBearer
from firebase_admin import auth
from firebase_admin.auth import EmailAlreadyExistsError, UserNotFoundError
from firebase_admin.exceptions import FirebaseError
from google.cloud import firestore
from jinja2 import Environment, FileSystemLoader, select_autoescape
from jose import jwt
from magic_admin import Magic
from magic_admin.error import (
    MagicError,
)
from sqlalchemy.orm import Session
from starlette import status

from app import crud, security
from app.config.settings import get_settings, Settings
from app.database import get_db
from app.schemas.auth import (
    AuthenticationRequest,
    AuthenticationResponse,
    TokenData,
    UserMetadata,
    UserInvitation,
    CheckEnvelopeResponse,
    MagicAuthResponse,
    MagicAuthRequest,
    ExtraFeatureScaffold,
    AuthProbeRequest,
    CreateApiKeyResponse,
    ApiKeysListResponse,
    ApiKeyUpdateRequest,
)
from app.security import (
    firebase_app,
    JWT_ALGORITHM,
    JWT_SECRET_KEY,
    get_logged_in_user_data,
)
from app.tags import TAG_AUTH

router = fastapi.APIRouter(prefix="/authenticate")
logger = structlog.get_logger()
rest_api_url = "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword"


SHELF_ANALYTICS_USER_METADATA_COLLECTION = "shelf-analytics-user-metadata"
SHELF_ANALYTICS_ROLE_READER = "reader"
SHELF_ANALYTICS_ROLE_ADMIN = "admin"


async def get_user_metadata(postgres_db: Session, uid: str) -> Optional[UserMetadata]:
    """
    Collect all the relevant metadata for the user:

    From firestore:
    - roles
    - full name
    - email address
    - id of the corresponding brand (client)

    From postgres:
    - brand name
    - access to extra features (`extra_features_registry` table)
    """
    db = firestore.AsyncClient()
    user_metadata = (
        await db.collection(SHELF_ANALYTICS_USER_METADATA_COLLECTION)
        .document(uid)
        .get()
    )

    if not user_metadata.exists:
        return None

    extra_features = [
        ExtraFeatureScaffold.from_orm(feature)
        for feature in crud.get_extra_features(postgres_db, user_metadata.get("client"))
    ]

    client_name = crud.get_brand_name(postgres_db, user_metadata.get("client"))

    return UserMetadata(
        **user_metadata.to_dict(), features=extra_features, client_name=client_name
    )


async def authenticate_verified_user(
    postgres_db: Session, uid: str
) -> AuthenticationResponse:
    """
    This method should only be called once the user has verified that they are who they pretend to be either by
    providing a valid firebase token or a valid magic did token
    """
    user_metadata = await get_user_metadata(postgres_db, uid)
    if not user_metadata:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=f"Could not properly fulfill the authentication request. User exists but no permissions assigned!",
            headers={"WWW-Authenticate": "Bearer"},
        )

    token_data = TokenData(uid=uid, **user_metadata.dict())

    # The token encodes user specific data, such as: brand name, roles etc.
    token = jwt.encode(
        {"data": token_data.dict(), "exp": datetime.utcnow() + timedelta(hours=48)},
        JWT_SECRET_KEY,
        JWT_ALGORITHM,
    )

    return AuthenticationResponse(jwt=token, success=True)


@router.post(
    "/withFirebaseToken", tags=[TAG_AUTH], response_model=AuthenticationResponse
)
async def authenticate_with_firebase_token(
    credential: HTTPAuthorizationCredentials = Depends(HTTPBearer(auto_error=False)),
    postgres_db: Session = Depends(get_db),
):
    """
    This method may be used if we are already logged into firebase through the frontend, so we use firebase's token
    to generate a backend token.

    It is the only endpoint in this API where the expected authentication is different. Here we expect a Firebase Bearer
    token, for all the other authenticated endpoints we expect a token generated by this app (through this method or the
    method that takes a username and password).

    Inspired by: https://stackoverflow.com/questions/72200552/fastapi-firebase-authentication-with-jwts
    """

    if credential is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Bearer authentication is needed",
            headers={"WWW-Authenticate": 'Bearer error="invalid token"'},
        )

    try:
        token = credential.credentials
        uid = auth.verify_id_token(token)["uid"]
        return await authenticate_verified_user(postgres_db, uid)
    except Exception as err:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=f"Could not validate credentials, {err}",
            headers={"WWW-Authenticate": "Bearer"},
        )


@router.post("/invite", tags=[TAG_AUTH], response_model=CheckEnvelopeResponse)
def invite_user_by_mail(
    invitation: UserInvitation,
    response: Response,
    inviting_user: TokenData = Depends(get_logged_in_user_data),
    postgres_db=Depends(get_db),
):
    if SHELF_ANALYTICS_ROLE_ADMIN not in inviting_user.roles:
        """
        Only admins are allowed to send out invitation.

        The ADMIN role is stored in the JWT token, so it might take up to 48 hours for the role to be reflected in
        the actual token. If the user wants to access this feature ASAP, they should log out and back into the loupe
        dashboard.
        """
        response.status_code = status.HTTP_401_UNAUTHORIZED
        return {"success": False}

    alphabet = string.ascii_letters + string.digits
    """
    Each firebase user is required to have a password. 
    
    We generate a random password that we don't store anywhere, and we never see it. In theory a user can be 
    authenticated using their email and this password, but since no one actually knows the password it's practically 
    impossible to use this authentication method. 
    
    This was done on purpose, since we want users to authenticate using Magic links or one time passwords.
    """
    password = "".join(secrets.choice(alphabet) for _ in range(20))

    try:
        new_user = auth.create_user(email=invitation.email, password=password)
        db = firestore.Client()
        db.collection(SHELF_ANALYTICS_USER_METADATA_COLLECTION).document(
            new_user.uid
        ).set(
            {
                **invitation.dict(),
                "roles": [SHELF_ANALYTICS_ROLE_READER],
                "client": inviting_user.client,
            }
        )

        brand_name = crud.get_brand_name(postgres_db, inviting_user.client)
        settings = get_settings()

        email_env = Environment(
            loader=FileSystemLoader("app/resources/email"),
            autoescape=select_autoescape(),
        )
        template = email_env.get_template("invite.html")
        template_data = {
            "inviter_name": inviting_user.first_name + " " + inviting_user.last_name,
            "brand_name": brand_name,
            "invite_link": f"{invitation.domain}/login?email={invitation.email}",
        }
        email_body = template.render(**template_data)
        email_response = requests.post(
            "https://api.postmarkapp.com/email",
            headers={
                "X-Postmark-Server-Token": settings.postmark_api_token,
                "Accept": "application/json",
                "Content-Type": "application/json",
            },
            json={
                "From": "Loupe <info@getloupe.co>",
                "To": f"{invitation.first_name} {invitation.last_name} <{invitation.email}>",
                "Subject": f"{inviting_user.first_name} {inviting_user.last_name} invited you to join the {brand_name} team",
                "HtmlBody": email_body,
                "MessageStream": "outbound",
            },
        )
        if email_response.status_code >= 300:
            logger.error("Error when sending email", response=email_response.json())
            raise HTTPException(500, detail="Error when sending email")

    except EmailAlreadyExistsError:
        response.status_code = status.HTTP_409_CONFLICT
        return {"success": False}

    return {"success": True}


@router.post("/magic", tags=[TAG_AUTH], response_model=MagicAuthResponse)
async def authenticate_with_magic_link(
    magic_request: MagicAuthRequest, postgres_db: Session = Depends(get_db)
):
    """
    Authenticate using a magic did token.

    In the frontend we created a special Microsoft Outlook login case. This was triggered by the fact that Outlook has a
    checking function for URLs embedded in emails, so the Mail Server would open up the log in URL, which in turn logs
    the user in on the Mail Server.

    We detect this problem happening and route the user through a back-up log in flow based on One Time Passwords (OTP).

    All of this flow is defined on the front-end, the back-end Magic Auth is agnostic to this flow. It only cares about
    getting a valid magic did token which can be generated by either Magic Link or Magic OTP.
    """
    magic = Magic(api_secret_key=get_settings().magic_api_secret_key)
    try:
        # Validate the token using Magic's API. If the token is invalid, this invocation throws an error
        magic.Token.validate(magic_request.did_token)
        metadata = magic.User.get_metadata_by_token(magic_request.did_token)
        email = metadata.data["email"]
        user = auth.get_user_by_email(email)
        authentication_response = await authenticate_verified_user(
            postgres_db, user.uid
        )
        firebase_token = auth.create_custom_token(user.uid, app=firebase_app)
        return {**authentication_response.dict(), "firebase_token": firebase_token}
    except MagicError as e:
        logger.error("Could not validate magic token", err=str(e))
        return AuthenticationResponse(success=False)


@router.post("/probe", tags=[TAG_AUTH], response_model=CheckEnvelopeResponse)
def probe_user(
    body: AuthProbeRequest,
):
    try:
        auth.get_user_by_email(body.email)

        return {"success": True}
    except (ValueError, UserNotFoundError, FirebaseError) as e:
        return {"success": False}


@router.post("/keys", tags=[TAG_AUTH], response_model=CreateApiKeyResponse)
def create_api_key(
    db: Session = Depends(get_db),
    user: TokenData = Depends(get_logged_in_user_data),
):
    generated_key = security.generate_api_key()
    crud.save_api_key(db, generated_key, user)

    return {"success": True, "api_key": generated_key}


@router.get("/keys", tags=[TAG_AUTH], response_model=ApiKeysListResponse)
def get_api_keys(
    db: Session = Depends(get_db),
    user: TokenData = Depends(get_logged_in_user_data),
):
    api_keys = crud.get_api_keys(db, user)

    return {"keys": api_keys, "client": user.client}


@router.delete("/keys/{api_key}", tags=[TAG_AUTH])
def delete_api_key(
    api_key: str,
    user: TokenData = Depends(get_logged_in_user_data),
    db: Session = Depends(get_db),
):
    crud.delete_api_key(db, api_key, user)

    return {"success": True}


@router.get("/keys/{api_key_id}", tags=[TAG_AUTH], response_model=str)
def get_readable_api_key(
    api_key_id: str,
    user: TokenData = Depends(get_logged_in_user_data),
    db: Session = Depends(get_db),
):
    return crud.get_readable_api_key(db, api_key_id, user)


@router.put("/keys/{api_key_id}", tags=[TAG_AUTH])
def update_api_key(
    api_key_id: str,
    body: ApiKeyUpdateRequest,
    user: TokenData = Depends(get_logged_in_user_data),
    db: Session = Depends(get_db),
):
    crud.set_key_name(db, api_key_id, body.name, user)
    return {
        "success": True,
        "name": body.name,
    }
